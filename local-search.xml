<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>图文多模态大模型工作粗读</title>
    <link href="/2024/05/12/%E5%9B%BE%E6%96%87%E5%A4%9A%E6%A8%A1%E6%80%81%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%B7%A5%E4%BD%9C%E7%B2%97%E8%AF%BB/"/>
    <url>/2024/05/12/%E5%9B%BE%E6%96%87%E5%A4%9A%E6%A8%A1%E6%80%81%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%B7%A5%E4%BD%9C%E7%B2%97%E8%AF%BB/</url>
    
    <content type="html"><![CDATA[<p>MLLM</p><p><strong>Learning Transferable Visual Models From Natural Language Supervision</strong> (CLIP)</p><p>Motivation:</p><ul><li>当前迁移学习的流行范式仍然需要少量任务特定样本对模型进行微调，作者希望利用自然语言做监督信号实现零样本学习。</li><li>之前的工作受限于模型发展和数据规模效果不佳，作者采用先进的transformer模型，构建了从互联网爬取的包含4亿图像文本对的数据集WIT。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/GaoZhitao121/picture_bed@main//blog-img/image-20240511193310600.png" alt="CLIP"></p><p>CLIP核心思想是通过<strong>海量</strong>的<strong>弱监督</strong>图像文本对通过对比学习，将图片和文本通过各自的<strong>预训练</strong>模型获得的编码向量在向量空间上<strong>对齐</strong>。</p><p>为什么是弱监督的呢？我想这里并非只有对角线上的才严格匹配，比如一个图是狗狗，一个batch里面其他文本也可能有狗狗。还有就是互联网上的这种图像文本对无法保证数量，也就是说并不是严格aligned的。</p><p>CLIP的zero-shot能力突出，可以在没有见过的数据上完成分类，我认为这可能来源于其庞大的数据量（来自互联网的四亿个图像文本对）。大力出奇迹。</p><hr><p><strong>BLIP: Bootstrapping Language-Image Pre-training for Unified Vision-Language Understanding and Generation</strong></p><p>motivation：</p><ul><li><p>Bootstrapping: 用于训练的图像文本数据存在噪声（从互联网上爬取），如何清洗噪声？</p></li><li><p>Unified:encoder-model(理解)不适合做文本生成，encoder-decoder model（生成）不适合做图像文本检索，正如标题中Unified Vision-Language Understanding and Generation，作者想做一个<strong>多任务模型</strong>。</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/GaoZhitao121/picture_bed@main//blog-img/image-20240511201902580.png" alt="BLIP"></p><p>三塔模型，相同颜色共享参数。</p><p>模型：</p><ul><li><p>图像分支：ImageNet预训练的ViT-8</p></li><li><p>文本多任务分支：</p><ul><li>Text-encoder(对比学习图像文本匹配分支): 预训练的Bert，对比学习I和T向量尽量对齐。</li><li>Image-grounded text encoder(二分类图像文本细粒度匹配分支)： CA模块插入图像特征</li></ul><blockquote><p>二分类任务一个关键的点是如何构造负样本，具体来讲，是足够难的负样本，这里可以用ITC任务失败的图像文本对来作为负样本。</p></blockquote><ul><li>Image-grounded text decoder(生成文本描述)：CSA代替BSA，MASK后续token，避免待预测token泄露</li></ul></li></ul><p>如何处理噪声数据：</p><p><img src="https://cdn.jsdelivr.net/gh/GaoZhitao121/picture_bed@main//blog-img/image-20240511202246302.png" alt="BLIP"></p><p>​这是BLIP的另一大贡献，如何<strong>清洗弱监督的图像文本数据</strong>。</p><ul><li><p>第一步，我们在训练时把人标注的，我们认为顶级数据和互联网上标注的，一般的，可能存在的噪声数据，一起放进去训练，然后拿这份数据去pretrain ITC，ITM和LM的训练。</p></li><li><p>第二步，我们用人类的标注数据去tuning 这3个下游任务。这样，这3个模型其实就接近于我们想要的效果了，符合了下游任务的范式，这还没完。</p></li><li><p>第三步，把互联网标注的语料，拿ITC，和ITM给过滤了（判断图文是否匹配），错的，我就不要了，只留下好的，就是Tw的绿色部分，另外还可以用LM来标注成Ts（可能不准确）过滤一遍，再和老的数据，重新灌注给模型的变成新的pretrain，完成下一个epoch，周而复始，把不断迭代优化Loss。</p></li></ul><p>​以上就是Blip的创新和训练方式。</p><hr><p><strong>BLIP-2: Bootstrapping Language-Image Pre-training with Frozen Image Encoders and Large Language Models</strong></p><p><img src="https://cdn.jsdelivr.net/gh/GaoZhitao121/picture_bed@main//blog-img/image-20240511204632454.png" alt="BLIP2"></p><p>​BLIP的缺点是要重新训练模型，训练的参数量还比较大。且还有一个数据的问题，图像数据很多，文本数据也很多，那么图像文本对的数据就比较少了，CLIP这里是爬取的互联网上的图片和注释，噪声较多。</p><p>​左边是表征学习，右边是生成学习。</p><p>创新点：</p><ul><li>在Image Encoder和LLM中间搭建了一座桥(轻量架构QFormer（querying transformer）来建立图像-文本的对齐的bridge)，将表征学习得到的向量投射到文本向量附近，能够被语言模型所理解（图像prompt），而图像encoder和文本decoder是被冻结而不需要参数的。只需要训练Q-Former即可。</li><li>二阶段预训练范式实现高效训练，实现将目前的视觉backbone与LLM模型连接起来。 (后面就随便换了，LLM越强，模型越强，比如GPT4…)</li></ul><blockquote><p>表征学习：在保留图像信息的前提下变为一个向量。</p></blockquote><p>训练阶段一：训练Q-Former</p><p><img src="https://cdn.jsdelivr.net/gh/GaoZhitao121/picture_bed@main//blog-img/image-20240512191626001.png" alt="BLIP2"></p><p>训练阶段二：将对齐后的表征向量映射到LLM中，使得模型获得图片信息，进行指令微调。</p><p><img src="https://cdn.jsdelivr.net/gh/GaoZhitao121/picture_bed@main//blog-img/image-20240512192417498.png" alt="QFORMER"></p><img src="https://cdn.jsdelivr.net/gh/GaoZhitao121/picture_bed@main//blog-img/image-20240512214432229.png" alt="image-20240512214432229" style="zoom:50%;" /><p>缺点：对细节的处理不到位，可能是ViT图像编码器的限制，不能把所有的细节都抽出来。（教科书示意图问答）</p><hr><p><strong>LLaVA:Visual Instruction Tuning</strong></p><p><img src="https://cdn.jsdelivr.net/gh/GaoZhitao121/picture_bed@main//blog-img/image-20240511193627474.png" alt="llava"></p><p>它是2阶段训练：</p><p>   第一阶段，拿clip 的image encoder来训练，冻结住LLM，经过一个W的project转换（可以理解为线性层的矩阵对齐），说白了，就是一个线性层，image转换embedding的层W。第一阶段是将image和text特征进行对齐。</p><p>  第二阶段，冻住image encoder，然后再训练W和LLM，它是将图片还有prompt的语料（这prompt语料是GPT生成的关于这个图片的问题）一齐作为输入，然后把这个东西输入进随便什么LLM来训练，也是有监督的，监督的label就是生成的响应语句，求Loss。第二阶段是让大语言模型理解图片和文本，并具有多轮对话能力，是一个微调过程</p><hr><p>总结：</p><p>① 更强大的单模态模型影响效果。</p><p>② LLM指令学习丰富VQA任务数据。</p><p>③ 冻结大模型保留表征能力，对特征进行对齐。</p><p>反思：</p><p>① 使用LLM帮助生成数据会引入噪声信息。夹带私货？</p><p>② 示意图问答要求更加细粒度图像特征，如何得到。</p><p>③ 多模态大模型在教科书示意图问答方面如何应用。</p><p>挖坑：transformer llm</p>]]></content>
    
    
    <categories>
      
      <category>论文阅读</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>What Is ChatGPT Doing and Why Does it Work?</title>
    <link href="/2024/05/05/Work/"/>
    <url>/2024/05/05/Work/</url>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/GaoZhitao121/picture_bed@main//blog-img/image-20240505213238713.png" alt="image-20240505213238713"></p><p>中文译版：<a href="https://hub.baai.ac.cn/view/24216">Stephen Wolfram｜ChatGPT 在做什么，以及它为何发挥作用 - 智源社区 (baai.ac.cn)</a></p><p>一篇从更高维度讲解神经网络&#x2F;ChatGPT的文章。</p><p><em><strong>人类语言（及其背后的思维模式）在结构上恐怕比我们想象的更简单、更具有“法则性”。而ChatGPT恰巧隐式的发现了这个法则。</strong></em></p>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>差分解决区间增量</title>
    <link href="/2024/05/04/%E5%B7%AE%E5%88%86%E8%A7%A3%E5%86%B3%E5%8C%BA%E9%97%B4%E5%A2%9E%E9%87%8F/"/>
    <url>/2024/05/04/%E5%B7%AE%E5%88%86%E8%A7%A3%E5%86%B3%E5%8C%BA%E9%97%B4%E5%A2%9E%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<p>题目链接<a href="https://leetcode.cn/problems/corporate-flight-bookings/description/">1109. 航班预订统计 - 力扣（LeetCode）</a></p><p><strong>就这</strong>？上来一个暴力！</p><img src="C:/Users/GZT/AppData/Roaming/Typora/typora-user-images/image-20240504161332454.png" alt="image-20240504161332454" style="zoom:50%;" /><p><strong>阿这</strong>。大意了，没有闪。</p><p>注意到一个预订记录实际上代表了一个区间的增量。我们的任务是将这些增量叠加得到答案。因此，我们可以使用差分解决本题。</p><p>对于每条记录<code>[l,r,inc]</code>只需要O(1)地修改差分数组的<code>[l-1]</code>和<code>[r]</code>即可，特别的，当<code>r=n</code>时不做修改，这时候对应到差分数组内下标越界了，其实不用管这个，修改<code>[r]</code>决定了<code>[l-1]</code>的影响范围，越界自然地决定了这个范围。最后将差分数组求解前缀和即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">corpFlightBookings</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; bookings, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nums</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; booking : bookings) &#123;<br>            nums[booking[<span class="hljs-number">0</span>] - <span class="hljs-number">1</span>] += booking[<span class="hljs-number">2</span>];<br>            <span class="hljs-keyword">if</span> (booking[<span class="hljs-number">1</span>] &lt; n) &#123;<br>                nums[booking[<span class="hljs-number">1</span>]] -= booking[<span class="hljs-number">2</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            nums[i] += nums[i - <span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> nums;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>差分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>足球队员射门能力排序</title>
    <link href="/2024/04/26/c++%E5%88%B7%E9%A2%98/"/>
    <url>/2024/04/26/c++%E5%88%B7%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="足球队员射门能力排序"><a href="#足球队员射门能力排序" class="headerlink" title="足球队员射门能力排序"></a>足球队员射门能力排序</h3><p>球队有n个足球队员参与m次射门训练，每次射门进球用1表示，射失则用0表示，依据如下规则对该n个队员的射门能力做排序 1、进球总数更多的队员射门能力更强 2、若进球总数—样多，则比较最多—次连续进球的个数，最多的队员能力更强 3、若最多一次连续进球的个数一样多，则比较第一次射失的先后顺序，其中后射失的队员更强，若第一次射失顺序相同，则按继续比较第二次射失的顺序，后丢球的队员能术更强，依次类推 4、若前3个规则排序后还能力相等，则队员编号更小的能力更强</p><p><strong>输入</strong></p><p>第1行，足球队员数n，射门训练次数m。(队员编号从1开始，依次递增) 第2行，第1~n个队员从第1到m次训练的进球情况，每个队员进球情况为连续的1和0的组合，不同队员用空格分隔n和m均为正整数，0&lt;n&lt;&#x3D;10 ^ 3，0&lt;m&lt;&#x3D;10^3</p><p><strong>输出</strong></p><p>射门能力从强到弱的队员编号,用空格分隔</p><p><strong>样例1</strong></p><p><strong>输入:</strong></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">4 </span><span class="hljs-number">5</span><br><span class="hljs-symbol">11100 </span><span class="hljs-number">00111</span> <span class="hljs-number">10111</span> <span class="hljs-number">01111</span><br></code></pre></td></tr></table></figure><p><strong>输出:</strong></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">4 </span><span class="hljs-number">3</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>解释:4个队员，射门训练5次，队员3和4进球数均为4个，比队员1和2的3个更多,队员3连续进球数最多一次为3个,而队员4最大为4，因此队员4射门能力强于队员3,另外队员2比队员1先丢球，因此队员1射门能力强于队员2，排序为4312</p><p><strong>样例2</strong></p><p><strong>输入:</strong></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">2 </span><span class="hljs-number">10</span><br><span class="hljs-symbol">1011100111 </span><span class="hljs-number">1011101101</span><br></code></pre></td></tr></table></figure><p><strong>输出:</strong></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">2 </span><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>解释:2个队员，射门训练10次，两个队员的进球总数均为7个,连续进球最多的均为3个，且第前两次丢球顺序均为第二次和第6次训练射门，而队员2第三次丢球为第9次训练,队员2为第7次训练，因此队员2的射门能力强于队员1,排序为21</p><hr><p>题目本身不难，也可以很快有思路动笔去写，然而很多地方不太熟悉了，排序也是用的冒泡。。。应该使用C++标准库中的<code>sort()</code>函数，同时<strong>定义一个自定义的比较函数或Lambda表达式来实现排序规则</strong>。同时题目关于字符串的处理也是一个需要考虑的点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 结构体用于保存球员的信息</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Player</span> &#123;<br>    <span class="hljs-type">int</span> id;<br>    <span class="hljs-type">int</span> goals;<br>    <span class="hljs-type">int</span> max_consecutive_goals;<br>    vector&lt;<span class="hljs-type">int</span>&gt; misses;<br>&#125;;<br><br><span class="hljs-comment">// 比较函数，用于排序</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">comparePlayers</span><span class="hljs-params">(<span class="hljs-type">const</span> Player &amp;p1, <span class="hljs-type">const</span> Player &amp;p2)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (p1.goals != p2.goals) &#123;<br>        <span class="hljs-keyword">return</span> p1.goals &gt; p2.goals;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (p1.max_consecutive_goals != p2.max_consecutive_goals) &#123;<br>        <span class="hljs-keyword">return</span> p1.max_consecutive_goals &gt; p2.max_consecutive_goals;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; p1.misses.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>        <span class="hljs-keyword">if</span> (p1.misses[i] != p2.misses[i]) &#123;<br>            <span class="hljs-keyword">return</span> p1.misses[i] &gt; p2.misses[i];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> p1.id &lt; p2.id;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, m;<br>    cin &gt;&gt; n &gt;&gt; m;<br><br>    <span class="hljs-function">vector&lt;Player&gt; <span class="hljs-title">players</span><span class="hljs-params">(n)</span></span>;<br><br>    <span class="hljs-comment">// 读取球员的进球情况</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        players[i].id = i + <span class="hljs-number">1</span>;<br>        players[i].goals = <span class="hljs-number">0</span>;<br>        players[i].max_consecutive_goals = <span class="hljs-number">0</span>;<br>        players[i].misses.<span class="hljs-built_in">resize</span>(m);<br><br>        string shots;<br>        cin &gt;&gt; shots;<br><br>        <span class="hljs-type">int</span> consecutive_goals = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; ++j) &#123;<br>            <span class="hljs-keyword">if</span> (shots[j] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                players[i].goals++;<br>                consecutive_goals++;<br>                players[i].max_consecutive_goals = <span class="hljs-built_in">max</span>(players[i].max_consecutive_goals, consecutive_goals);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                consecutive_goals = <span class="hljs-number">0</span>;<br>            &#125;<br>            players[i].misses[j] = shots[j];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 对球员进行排序</span><br>    <span class="hljs-built_in">sort</span>(players.<span class="hljs-built_in">begin</span>(), players.<span class="hljs-built_in">end</span>(), comparePlayers);<br><br>    <span class="hljs-comment">// 输出排名结果</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        cout &lt;&lt; players[i].id &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><p><code>sort</code> 函数可以接受一个自定义的比较函数，以便在排序时按照指定的规则进行排序。在 C++ 中，自定义的比较函数可以是一个函数或者一个函数对象（Functor）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 自定义比较函数</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">customCompare</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    <span class="hljs-comment">// 这里定义了一些自定义的排序规则</span><br>    <span class="hljs-comment">// 返回 true 表示 a 应该在 b 之前，返回 false 表示 a 应该在 b 之后</span><br>    <span class="hljs-comment">// 例如，按照从大到小排序</span><br>    <span class="hljs-keyword">return</span> a &gt; b;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; nums = &#123;<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">9</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>&#125;;<br><br>    <span class="hljs-comment">// 使用自定义的比较函数进行排序</span><br>    <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>(), customCompare);<br><br>    <span class="hljs-comment">// 输出排序结果</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>        cout &lt;&lt; num &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>也可以用<strong>Lamda</strong>函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; nums = &#123;<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">9</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>&#125;;<br><br>    <span class="hljs-comment">// 使用 lambda 函数进行自定义排序</span><br>    <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b) &#123;<br>        <span class="hljs-comment">// 这里定义了自定义的排序规则</span><br>        <span class="hljs-comment">// 返回 true 表示 a 应该在 b 之前，返回 false 表示 a 应该在 b 之后</span><br>        <span class="hljs-comment">// 例如，按照从大到小排序</span><br>        <span class="hljs-keyword">return</span> a &gt; b;<br>    &#125;);<br><br>    <span class="hljs-comment">// 输出排序结果</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>        cout &lt;&lt; num &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>lambda 函数 <code>[](int a, int b) &#123; return a &gt; b; &#125;</code> 定义了一个简单的比较函数，用于按照从大到小的顺序进行排序。该 lambda 函数接受两个整数参数 <code>a</code> 和 <code>b</code>，并返回一个 <code>bool</code> 值，表示是否应该将 <code>a</code> 放在 <code>b</code> 之前。然后，我们将这个 lambda 函数作为第三个参数传递给 <code>sort</code> 函数，使得 <code>sort</code> 函数按照我们定义的规则对向量进行排序。</p>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hello world!</title>
    <link href="/2024/04/20/hello-world/"/>
    <url>/2024/04/20/hello-world/</url>
    
    <content type="html"><![CDATA[<blockquote><p><em><strong>你好，世界</strong></em></p></blockquote><p>这里是我的个人博客中的第一篇博文。</p><p>心血来潮，花了半个小时使用<code>github</code>+<code>hexo</code>草草搭建了一个博客(也可能不用过多久就不再更新 了)</p><p>第一篇文章，索性记录一下如何使用<code>hexo</code>发布文章。</p><p><strong>打开git bash</strong></p><p>​在自己的本地博客文件夹中~</p><p><strong>输入指令</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># hexo new 文章标题</span><br> &gt;&gt;&gt; hexo new 如何在hexo博客写作<br> <span class="hljs-comment"># 或者是</span><br> <span class="hljs-comment"># hexo new 文章标题 --path 路径/文件名.md</span><br> <span class="hljs-comment"># 或者可以简写一下</span><br> <span class="hljs-comment"># hexo new 文章标题 -p 路径/文件名.md</span><br> &gt;&gt;&gt; hexo new <span class="hljs-string">&quot;如何在hexo博客写作&quot;</span> -p 计算机科学/博客/如何在hexo博客写作.md<br> <span class="hljs-comment"># tips：如果不设置路径的话，新建文章是默认存储在\source\_posts\这个路径下的。</span><br> <span class="hljs-comment"># tips：一般在标题下有空格或者其他字符要给标题加上双引号</span><br></code></pre></td></tr></table></figure><p><strong>编辑博文</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs markdown">title: 如何在hexo博客写作          #文章标题<br>date: 2022-04-13 11:52:06        #文章创建时间<br>tags:                       #文章标签<br><span class="hljs-bullet">   -</span> 博客<br><span class="hljs-bullet">   -</span> 每日一更<br>categories:                     #文章类别<br><span class="hljs-bullet">   -</span> 计算机科学<br><span class="hljs-bullet">   -</span> 博客<br><span class="hljs-bullet">   -</span> 博客的食用方法<br></code></pre></td></tr></table></figure><p><strong>发布！</strong></p><p>hexo三连</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo clean<br>hexo g<br>hexo d<br></code></pre></td></tr></table></figure><p>也可以先本地预览</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo s</span><br></code></pre></td></tr></table></figure><hr><p>就酱！想到什么了再补充。</p><p><img src="https://pica.zhimg.com/80/v2-8c1fbe93975e4ef94b5845bbbabb75f2_1440w.webp"></p><div style="text-align: right;">    <em>2024/04/20 于钱学森图书馆</em></div>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
